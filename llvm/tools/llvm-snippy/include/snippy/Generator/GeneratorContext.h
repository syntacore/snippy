//===-- GeneratorContext.h -------  -----------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#pragma once

#include "snippy/Config/CallGraphLayout.h"
#include "snippy/Config/MemoryScheme.h"
#include "snippy/Config/OpcodeHistogram.h"
#include "snippy/Generator/BurstMode.h"
#include "snippy/Generator/CallGraphState.h"
#include "snippy/Generator/GeneratorSettings.h"
#include "snippy/Generator/GlobalsPool.h"
#include "snippy/Generator/ImmediateHistogram.h"
#include "snippy/Generator/LLVMState.h"
#include "snippy/Generator/MemoryManager.h"
#include "snippy/Generator/Policy.h"
#include "snippy/Generator/RegisterGenerator.h"
#include "snippy/Generator/RegisterPool.h"
#include "snippy/Generator/SimRunner.h"
#include "snippy/Target/Target.h"

#include "llvm/CodeGen/MachineModuleInfo.h"
#include "llvm/Support/Debug.h"
namespace llvm {
class MachineModuleInfo;
class TargetSubtargetInfo;
} // namespace llvm

namespace llvm {
namespace snippy {

class ImmediateHistogram;
class InitialReg;
class Interpreter;
class LLVMState;
class MemoryScheme;
class OpcodeCache;
class RootRegPoolWrapper;
struct TargetGenContextInterface;
class Linker;
class GlobalsPool;
struct IRegisterState;

struct GeneratorResult {
  std::string SnippetImage;
  std::string LinkerScript;
};

enum class GenerationMode {
  // Ignore Size requirements, only num Instrs
  NumInstrs,
  // Ignore num instrs, try to meet size requirements
  Size,
  // Try to satisfy both num instrs and size requirements
  Mixed
};

using BurstGroupAccessDesc = std::vector<AddressInfo>;
using PlainAccessesType = std::vector<AccessAddress>;
using BurstGroupAccessesType = std::vector<BurstGroupAccessDesc>;

class GeneratorContext {
public:
  struct LoopGenerationInfo {
    Register CounterReg;
    unsigned NumIter;
    unsigned SmallestCounterVal;
  };

private:
  friend RootRegPoolWrapper;

  constexpr static auto SmallStringDefaultSize = 16;
  constexpr static auto SCStride = 16u;
  constexpr static auto kPageSize = 0x1000u;

  MachineModuleInfo *MMI = nullptr;
  LLVMState *State = nullptr;
  std::vector<RegPool> RegPoolsStorage;
  RegisterGenerator *RegGen = nullptr;
  std::unique_ptr<CallGraphState> CGS;

  const OpcodeCache *OpCC = nullptr;
  std::unique_ptr<Linker> PLinker;
  std::unique_ptr<GlobalsPool> GP;
  mutable std::unique_ptr<IRegisterState> InitialMachineState;
  mutable std::unique_ptr<SimRunner> Runner;
  DenseMap<MemAddr, MemAddr> SelfcheckMap;
  bool HasTrackingMode = false;

  GeneratorSettings *GenSettings = nullptr;
  std::unique_ptr<TargetGenContextInterface> TargetContext;

  void initRunner() const;

  SectionDesc SelfcheckSection;

  std::optional<SectionDesc> StackSection;

  // Keeps all memory accesses generated by main instructions.
  PlainAccessesType PlainAccesses;
  // Keeps all range-based description of memory accesses generated by
  // instructions from burst groups.
  BurstGroupAccessesType BurstRangeAccesses;
  // Keeps all memory accesses generated by instructions from burst groups. One
  // instruction in burst group = one address.
  PlainAccessesType BurstPlainAccesses;

  size_t EntryPrologueInstrCnt = 0;
  size_t EntryEpilogueInstrCnt = 0;

  DenseMap<const MachineBasicBlock *, LoopGenerationInfo> LoopInfoMap;

  void diagnoseSelfcheckSection(size_t MinSize) const;

  void initializeStackSection();

  // A map that keeps SOME registers to value pairs for SOME blocks. This is
  // needed only in selfcheck mode and only for blocks which can be entered in
  // an order that doesn't match execution order.
  // Let's consider an example: we're generating a loop in selfcheck mode. Loops
  // in this mode have a special structure that is
  //        ...
  //         |
  //  +------v-----+
  //  |            |
  //  |  preheader |
  //  |            |
  //  +------+-----+
  //         |
  //         | --------------------------
  //         |/                          \
  //  +------v-----+                     |
  //  |            |                     |
  //  |   header   |                     |
  //  |            |                     |
  //  +------+-----+                     |
  //         |                           |
  //         |                           |
  //        ... (other loop body blocks) |
  //         |                           |
  //         |                           |
  //  +------v--------+                  |
  //  |               |                  |
  //  |    exiting    |                  |
  //  |               |                  |
  //  +------+-+------+   +-----------+  |
  //         | \          |           |  |
  //         |  ---------->   latch   |  |
  //  +------v-----+      |           |  |
  //  |            |      +-----+-----+  |
  //  |    exit    |            \        /
  //  |            |             --------
  //  +------------+
  //
  // Let's say that the loop has two iterations and conditional jump in exiting
  // block is `bne r1, r2, latch`. We have an agreement that in selfcheck mode
  // each iteration of the loop must do the same, difference might be only in
  // the stack as it's a supportive structure. Stack keeps actual values of
  // induction variables which for the loop above will be written to `r1`, `r2`
  // and compared(`bne`).
  //
  // Moving further with the example: at instructions generation stage we'll
  // visit blocks in the following order:
  //   preheader -> header -> other body blocks -> exiting -> latch -> exit.
  //
  // As you can see, we won't execute the second iteration of the loop. When
  // moving interpreter execution to exit block, we have the correct state of
  // registers/memory in interprepator except for r1 and r2 (as we execute only
  // one iteration). However, expected values of r1 and r2 are known statically
  // at loop latcher stage. So, we'll save these values in the map below and
  // write them in interpreter before executing the exit block.
  using RegToValueType = DenseMap<Register, APInt>;
  std::unordered_map<const MachineBasicBlock *, RegToValueType> IncomingValues;

  OpcodeToImmHistSequenceMap ImmHistMap;

  //       +---v---+
  //       |       |
  //       +---+---+
  //           | ______    ------------------------------
  //           |/      \
  //       +---v---+   |
  //       |       |   |      First consecutive loop
  //       +---+---+   |
  //           |\______/
  //           | ______    ------------------------------
  //           |/      \
  //       +---v---+   |
  //       |       |   |
  //       +---+---+   |
  //           |\______/
  //           | ______
  //           |/      \
  //       +---v---+   |
  //       |       |   |      Other consecutive loops
  //       +---+---+   |
  //           |\______/
  //           | ______
  //           |/      \
  //       +---v---+   |
  //       |       |   |
  //       +---+---+   |
  //           |\______/
  //           |           ------------------------------
  //           |
  //       +---v---+
  //       |       |
  //       +---+---+
  //
  // First loop header <-> Consecutive loops headers (basic blocks numbers)
  std::unordered_map<unsigned, std::set<unsigned>> ConsecutiveLoopsHeaders;

public:
  GeneratorContext(MachineModuleInfo &MMI, Module &M, LLVMState &State,
                   RegPool &Pool, RegisterGenerator &RegGen,
                   GeneratorSettings &GenSettings, const OpcodeCache &OpCc);
  ~GeneratorContext();

  void addToSelfcheckMap(MemAddr Address, MemAddr Distance) {
    [[maybe_unused]] auto EmplaceResult =
        SelfcheckMap.try_emplace(Address, Distance);
    assert(EmplaceResult.second &&
           "This address has been already inserterd to map.");
  }

  void
  attachTargetContext(std::unique_ptr<TargetGenContextInterface> TgtContext);

  Interpreter &getOrCreateInterpreter() const;
  SimRunner &getOrCreateSimRunner() const;

  const IRegisterState &
  getInitialRegisterState(const TargetSubtargetInfo &Subtarget) const;
  StringRef getLastInstr() const {
    return GenSettings->InstrsGenerationConfig.LastInstr;
  }
  bool useRetAsLastInstr() const {
    return StringRef{"RET"}.equals_insensitive(
        GenSettings->InstrsGenerationConfig.LastInstr);
  }
  StringRef getEntryPointName() const {
    return GenSettings->LinkerConfig.EntryPointName;
  }
  StringRef getABIName() const { return GenSettings->ABIName; }

  auto isEntryFunction(const MachineFunction &MF) const {
    auto *F = &MF.getFunction();
    return CGS->getRootNode()->functions().front() == F;
  }

  auto isExitFunction(const MachineFunction &MF) const {
    auto *F = &MF.getFunction();
    return CGS->getRootNode()->functions().back() == F;
  }
  auto isRootFunction(const Function &F) const { return CGS->isRoot(&F); }
  auto isRootFunction(const MachineFunction &MF) const {
    return isRootFunction(MF.getFunction());
  }

  auto *nextRootFunction(const MachineFunction &MF) const {
    assert(isRootFunction(MF) && "MF must be in root group.");
    auto *F = &MF.getFunction();
    auto *Root = CGS->getNode(&MF.getFunction());
    auto Found =
        llvm::find_if(Root->functions(), [F](auto *E) { return F == E; });
    assert(Found != Root->functions().end() &&
           std::next(Found) != Root->functions().end() &&
           "Exit function does not have ancessor");
    return *std::next(Found);
  }

  StringRef getOutputSectionName(const Function &F) const {
    return F.hasSection() ? F.getSection() : ".text";
  }

  auto getOutputSectionFor(const Function &F) const {
    auto SectionName = getOutputSectionName(F);
    assert(PLinker->hasOutputSectionFor(SectionName));
    return PLinker->getOutputSectionFor(SectionName).Desc;
  }

  auto getOutputSectionFor(const MachineFunction &MF) const {
    auto &F = MF.getFunction();
    return getOutputSectionFor(F);
  }

  auto getRequestedInstrsNumForMainFunction() const {
    return GenSettings->InstrsGenerationConfig.NumInstrs.value_or(0);
  }

  size_t getRequestedInstrsNum(const MachineFunction &MF) const {
    if (isRootFunction(MF))
      return (double)getRequestedInstrsNumForMainFunction() *
             ((double)getOutputSectionFor(MF).Size /
              (double)GenSettings->Cfg.Sections.getSectionsSize(Acc::X));
    else
      return GenSettings->Cfg.CGLayout.InstrNumAncil;
  }

  bool isLoopGenerationPossible() const {
    assert(GenSettings);
    assert(OpCC);
    const auto &Branches = GenSettings->Cfg.Branches;
    const auto &Histogram = GenSettings->Cfg.Histogram;
    return Branches.LoopRatio > std::numeric_limits<double>::epsilon() &&
           Branches.PermuteCF && Branches.MaxDepth.Loop > 0 &&
           Histogram.hasCFInstrs(*OpCC);
  }

  bool isInstrsNumKnown() const {
    return GenSettings->InstrsGenerationConfig.NumInstrs.has_value();
  }
  bool isManglingEnabled() const {
    return GenSettings->LinkerConfig.MangleExportedNames;
  }
  const BurstGramData &getBurstGram() const {
    return *GenSettings->Cfg.Burst.Data;
  }

  void notifyMemUpdate(uint64_t Addr, const APInt &Value) const;

  auto &getMMI() const { return *MMI; }
  auto &getLLVMState() const { return *State; }

  auto &getConfig() const {
    assert(GenSettings);
    return GenSettings->Cfg;
  }

  GenerationMode getGenerationMode() const {
    if (!isInstrsNumKnown())
      return GenerationMode::Size;
    bool PCDistanceRequested = getConfig().Branches.isPCDistanceRequested();
    return PCDistanceRequested ? GenerationMode::Mixed
                               : GenerationMode::NumInstrs;
  }

  auto &getOpcodeToImmHistMap() const { return ImmHistMap; }

  auto &getSelfcheckSection() const { return SelfcheckSection; }

  // We return by value here to enforce copy
  RegPoolWrapper getRegisterPool() { return {RegPoolsStorage}; }

  Linker &getLinker() const { return *PLinker; }
  RegisterGenerator &getRegGen() const { return *RegGen; }
  GlobalsPool &getGlobalsPool() const { return *GP; }
  auto &getCallGraphState() const { return *CGS; }
  auto &getMemoryScheme() { return GenSettings->Cfg.MS; }
  const auto &getOpcodeCache() const { return *OpCC; }
  const auto &getGenSettings() const {
    assert(GenSettings);
    return *GenSettings;
  }
  const auto &getCallGraphLayout() const { return GenSettings->Cfg.CGLayout; }

  template <typename It> size_t getCodeBlockSize(It Begin, It End) const {
    return std::accumulate(
        Begin, End, 0ul, [this](auto CurrentSize, const auto &MI) {
          size_t InstrSize = MI.getDesc().getSize();
          if (InstrSize == 0)
            snippy::warn(
                WarningName::InstructionSizeUnknown, getLLVMState().getCtx(),
                [&MI]() {
                  std::string Ret;
                  llvm::raw_string_ostream OS{Ret};
                  OS << "Instruction '";
                  MI.print(OS, /* IsStandalone */ true, /* SkipOpers */ true,
                           /* SkipDebugLoc */ true, /* AddNewLine */ false);
                  OS << "' has unknown size";
                  return Ret;
                }(),
                "function size estimation may be wrong");
          return CurrentSize + InstrSize;
        });
  }
  size_t getMBBSize(const MachineBasicBlock &MBB) const {
    return getCodeBlockSize(MBB.begin(), MBB.end());
  }

  size_t getFunctionSize(const MachineFunction &MF) const {
    return std::accumulate(
        MF.begin(), MF.end(), 0ul,
        [this](auto CurrentSize, const auto &MBB) { return getMBBSize(MBB); });
  }

  void addLoopGenerationInfoForMBB(const MachineBasicBlock *Header,
                                   LoopGenerationInfo LGI) {
    assert(Header);
    [[maybe_unused]] bool Inserted = LoopInfoMap.insert({Header, LGI}).second;
    assert(Inserted);
  }

  std::optional<LoopGenerationInfo>
  getLoopsGenerationInfoForMBB(const MachineBasicBlock *Header) {
    assert(Header);
    auto Found = LoopInfoMap.find(Header);
    return Found == LoopInfoMap.end() ? std::nullopt
                                      : std::optional(Found->second);
  }

  using OpcodeFilter = std::function<bool(unsigned)>;
  // FIXME: Those should be GeneratorContext's methods
  std::unique_ptr<DefaultOpcodeGenerator> createDefaultOpcodeGenerator() const {
    return GenSettings->Cfg.createDefaultOpcodeGenerator();
  }

  OpcGenHolder createCFOpcodeGenerator() const {
    return GenSettings->Cfg.createCFOpcodeGenerator(*OpCC);
  }

  OpcGenHolder
  createFlowOpcodeGenerator(OpcodeFilter OpcMask, bool MustHavePrimaryInstrs,
                            ArrayRef<OpcodeHistogramEntry> Overrides) const {
    return GenSettings->Cfg.createDFOpcodeGenerator(*OpCC, OpcMask, Overrides,
                                                    MustHavePrimaryInstrs);
  }

  GenPolicy
  createGenerationPolicy(unsigned Limit, OpcodeFilter Filter,
                         bool MustHavePrimaryInstrs,
                         std::optional<unsigned> BurstGroupID,
                         ArrayRef<OpcodeHistogramEntry> Overrides = {}) const;
  auto getCFInstrsNum(const MachineFunction &MF) const {
    return GenSettings->Cfg.Histogram.getCFInstrsNum(getRequestedInstrsNum(MF),
                                                     *OpCC);
  }

  bool hasCallInstrs() const;

  bool hasCFInstrs() const {
    return GenSettings->Cfg.Histogram.hasCFInstrs(*OpCC);
  }

  void installSelfCheckSectionParams() const;

  constexpr unsigned getSCStride() const { return SCStride; }

  StringRef getInitialRegYamlFile() const {
    return GenSettings->RegistersConfig.InitialRegYamlFile;
  }

  TargetGenContextInterface &getTargetContext() const { return *TargetContext; }

  const TargetSubtargetInfo &getSubtargetImpl() const {
    auto &Module = *getMMI().getModule();
    auto ModuleIt = Module.begin();
    assert(ModuleIt != Module.end() &&
           "module must have at least one function");
    const Function &Fn = *ModuleIt;
    return *getLLVMState().getTargetMachine().getSubtargetImpl(Fn);
  }

  template <typename SubtargetType> const SubtargetType &getSubtarget() const {
    return static_cast<const SubtargetType &>(getSubtargetImpl());
  }

  bool mustRunLinker() const { return GP->totalSectionSize() > 0; }

  bool hasStackSection() const { return StackSection.has_value(); }
  auto getStackSection() const { return StackSection.value(); }
  bool hasExternalStack() const {
    return GenSettings->LinkerConfig.ExternalStack;
  }
  bool stackEnabled() const { return hasStackSection() || hasExternalStack(); }
  auto getStackTop() const {
    assert(hasStackSection() && "No stack section");
    auto &Stack = StackSection.value();
    return Stack.VMA + Stack.Size;
  }

  void setEntryPrologueInstructionCount(size_t Count) {
    EntryPrologueInstrCnt = Count;
  }

  void setEntryEpilogueInstuctionCount(size_t Count) {
    EntryEpilogueInstrCnt = Count;
  }

  size_t getEntryPrologueInstructionCount() const {
    return EntryPrologueInstrCnt;
  }

  size_t getEntryEpilogueInstructionCount() const {
    return EntryEpilogueInstrCnt;
  }

  ArrayRef<unsigned> getSpilledRegs() const {
    return GenSettings->RegistersConfig.SpilledRegs;
  }

  GeneratorResult generateELF(ObjectFilesList InputImages) const;

  std::string generateLinkedImage(ObjectFilesList InputImages) const;

  void checkMemStateAfterSelfcheck() const;

  void runSimulator(StringRef ImageToRun);

  bool hasTrackingMode() const { return HasTrackingMode; }
  void disableTrackingMode() { HasTrackingMode = false; }

  bool hasModel() const {
    return !GenSettings->ModelPluginConfig.ModelLibraries.empty();
  }

  // See description for `IncomingValues`.
  void addIncomingValues(const MachineBasicBlock *MBB,
                         RegToValueType RegToValue);
  const RegToValueType &getIncomingValues(const MachineBasicBlock *MBB);

  void addMemAccess(MemAddr Addr, size_t AccessSize) {
    PlainAccesses.emplace_back(AccessAddress{Addr, AccessSize});
  }
  void addBurstRangeMemAccess(BurstGroupAccessDesc BurstAccess) {
    BurstRangeAccesses.emplace_back(std::move(BurstAccess));
  }
  void addBurstPlainMemAccess(MemAddr Addr, size_t AccessSize) {
    BurstPlainAccesses.emplace_back(AccessAddress{Addr, AccessSize});
  }
  const PlainAccessesType &getMemAccesses() const { return PlainAccesses; }
  const BurstGroupAccessesType &getBurstRangeAccesses() const {
    return BurstRangeAccesses;
  }
  const PlainAccessesType &getBurstPlainAccesses() const {
    return BurstPlainAccesses;
  }

  bool isFirstConsecutiveLoopHeader(unsigned BB) const {
    return ConsecutiveLoopsHeaders.count(BB);
  }

  bool isNonFirstConsecutiveLoopHeader(unsigned BB) const {
    return any_of(make_second_range(ConsecutiveLoopsHeaders),
                  [BB](const auto &ConsLoops) { return ConsLoops.count(BB); });
  }

  void registerConsecutiveLoopsHeader(unsigned ConsecutiveLoopHeader,
                                      unsigned FirstLoopHeader) {
    ConsecutiveLoopsHeaders[FirstLoopHeader].insert(ConsecutiveLoopHeader);
  }

  const auto &getConsecutiveLoops(unsigned FirstConsecutiveLoop) const {
    assert(isFirstConsecutiveLoopHeader(FirstConsecutiveLoop));
    return ConsecutiveLoopsHeaders.at(FirstConsecutiveLoop);
  }

  const auto &getConsecutiveLoops() const { return ConsecutiveLoopsHeaders; }
};

} // namespace snippy
} // namespace llvm
