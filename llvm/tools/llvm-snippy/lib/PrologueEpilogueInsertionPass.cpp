//===-- PrologueEpilogueInsertionPass.cpp -----------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "InitializePasses.h"

#include "snippy/CreatePasses.h"
#include "snippy/Generator/FunctionGeneratorPass.h"
#include "snippy/Generator/GeneratorContextPass.h"

#include "llvm/ADT/STLExtras.h"
#include "llvm/CodeGen/MachineFunctionPass.h"

#define DEBUG_TYPE "snippy-prologue-epilogue-insertion"
#define PASS_DESC "Snippy Prologue Epilogue Insertion"

namespace llvm {
namespace snippy {
namespace {

struct PrologueEpilogueInsertion final : public MachineFunctionPass {
public:
  static char ID;

  PrologueEpilogueInsertion() : MachineFunctionPass(ID) {}

  StringRef getPassName() const override { return PASS_DESC " Pass"; }

  bool runOnMachineFunction(MachineFunction &MF) override;

  bool insertPrologue(MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
                      ArrayRef<MCRegister> SpilledToMem);
  bool insertEpilogue(MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
                      ArrayRef<MCRegister> SpilledToMem);

  auto getFunctionSizeInfo(const MachineFunction &MF) const {
    auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
    auto &State = SGCtx.getProgramContext().getLLVMState();
    return std::make_pair(State.getFunctionSize(MF),
                          SGCtx.getProgramContext().getOutputSectionFor(MF));
  }

  auto getAllMutatedRegs(MachineFunction &MF) {
    DenseSet<unsigned> MutatedRegs;
    for (auto &MBB : MF)
      for (auto &MI : MBB) {
        for (auto &Def : MI.defs()) {
          assert(Def.isReg() && "Expected register operand");
          MutatedRegs.insert(Def.getReg());
        }
        for (auto &Imp : MI.implicit_operands())
          if (Imp.isDef()) {
            assert(Imp.isReg() && "Expected register operand");
            MutatedRegs.insert(Imp.getReg());
          }
      }
    return MutatedRegs;
  }

  auto getSpilledRegs(MachineFunction &MF) {
    auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
    auto &FG = getAnalysis<FunctionGenerator>();
    bool IsRoot = FG.isRootFunction(MF);

    std::vector<MCRegister> Ret;

    if (IsRoot)
      llvm::copy(SGCtx.getGenSettings().getRegsSpilledToStack(),
                 std::back_inserter(Ret));
    else {
      auto RegSet = getAllMutatedRegs(MF);
      llvm::copy(RegSet, std::back_inserter(Ret));
    }

    return Ret;
  }

  void generateStackInitialization(InstructionGenerationContext &IGC);
  void generateStackTermination(InstructionGenerationContext &IGC);

  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForPrologue(MachineFunction &MF);
  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForEpilogue(MachineFunction &MF);

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.setPreservesCFG();
    AU.addRequired<GeneratorContextWrapper>();
    AU.addRequired<FunctionGenerator>();
    MachineFunctionPass::getAnalysisUsage(AU);
  }
};

char PrologueEpilogueInsertion::ID = 0;

} // namespace
} // namespace snippy
} // namespace llvm

using llvm::callDefaultCtor;
using llvm::PassInfo;
using llvm::PassRegistry;
using llvm::snippy::PrologueEpilogueInsertion;

INITIALIZE_PASS(PrologueEpilogueInsertion, DEBUG_TYPE, PASS_DESC, false, false)

namespace llvm {

MachineFunctionPass *createPrologueEpilogueInsertionPass() {
  return new PrologueEpilogueInsertion();
}

namespace snippy {

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForPrologue(MachineFunction &MF) {
  return std::make_pair(&MF.front(), MF.front().begin());
}

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForEpilogue(MachineFunction &MF) {
  auto &MBB = MF.back();

  // FIXME: we need to insert epilogue right before last instruction
  // generated by snippy. For now we know that it is single instruction
  // in the end of last basic block and that it is not required to be
  // terminator.
  auto InsertPos = MBB.empty() ? MBB.end() : std::prev(MBB.end());
  return std::make_pair(&MBB, InsertPos);
}

static MCRegister getRegisterForPreservedSPSpill(SnippyProgramContext &ProgCtx,
                                                 MachineBasicBlock &MBB) {
  auto &State = ProgCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  // If external stack is specified, we can use target-default stack pointer as
  // auxillary, because it is already initialized
  if (ProgCtx.hasExternalStack())
    return SnippyTgt.getStackPointer();

  auto RP = ProgCtx.getRegisterPool();
  const auto &RI = State.getRegInfo();
  const auto &RegClass = SnippyTgt.getRegClassSuitableForSP(RI);
  return RP.getAvailableRegister("scratch register for preserved reg spill", RI,
                                 RegClass, MBB);
}

static void setupStackPointer(InstructionGenerationContext &IGC,
                              MCRegister AuxReg) {
  auto &ProgCtx = IGC.ProgCtx;
  auto &State = ProgCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  auto TargetStackPointer = SnippyTgt.getStackPointer();

  if (ProgCtx.hasExternalStack()) {
    if (AuxReg != TargetStackPointer) // If we use external stack and redefine
                                      // stack pointer register in snippet, we
                                      // need to initialize redefined stack
                                      // pointer with the value in external one
      SnippyTgt.copyRegToReg(IGC, TargetStackPointer, AuxReg);
    return;
  }

  // Stack ponter is considered live on entry.
  IGC.MBB.addLiveIn(AuxReg);

  // Initialize stack.
  // This requires two steps:
  // 1 - save current stack pointer state to top of stack.
  // 2 - set stack pointer to point to next stack slot.
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(AuxReg, IGC);
  auto Addr = ProgCtx.getStackTop() - SPSpillSize;
  assert(Addr % SPSpillSize == 0u && "Stack section must be properly aligned");
  if (!IGC.GenSettings.isRegSpilledToMem(AuxReg))
    SnippyTgt.storeRegToAddr(IGC, Addr, AuxReg,
                             /* store the whole register */ 0);
  auto SPInitValue = Addr;
  SnippyTgt.writeValueToReg(
      IGC,
      APInt(SnippyTgt.getAddrRegLen(State.getTargetMachine()), SPInitValue),
      AuxReg);
}

static void restoreStackPointer(InstructionGenerationContext &IGC,
                                MCRegister AuxReg) {

  auto &ProgCtx = IGC.ProgCtx;
  const auto &SnippyTgt = ProgCtx.getLLVMState().getSnippyTarget();
  auto TargetStackPointer = SnippyTgt.getStackPointer();

  if (ProgCtx.hasExternalStack()) {
    if (AuxReg != TargetStackPointer) // Like during stack initialization,
                                      // both `external-stack` and
                                      // `redefine-sp` are specified, copying
                                      // stack pointer value to target-default
                                      // stack pointer is necessary on exit
      SnippyTgt.copyRegToReg(IGC, AuxReg, TargetStackPointer);
    return;
  }

  // Restore stack pointer state.
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(AuxReg, IGC);
  auto Addr = ProgCtx.getStackTop() - SPSpillSize;
  SnippyTgt.loadRegFromAddr(IGC, Addr, AuxReg);
}

void PrologueEpilogueInsertion::generateStackInitialization(
    InstructionGenerationContext &IGC) {
  auto &ProgCtx = IGC.ProgCtx;
  auto &State = ProgCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  auto RealStackPointer = ProgCtx.getStackPointer();

  // If honor-target-abi is specified and register, chosen for stack pointer
  // redefinition, is preserved, we:
  // 1. choose auxillary register, relatively to which we spill this redefined
  // stack pointer
  // 2. initialize stack with auxillary register as stack pointer
  // 3. spill "preserved stack pointer" relatively to auxillary register
  // 4. copy contents of auxillary register to "preserved stack pointer"
  auto AuxReg = RealStackPointer;
  if (ProgCtx.shouldSpillStackPointer())
    AuxReg = getRegisterForPreservedSPSpill(ProgCtx, IGC.MBB);

  setupStackPointer(IGC, AuxReg);

  // Spilling of preserved register, chosen for stack pointer role
  if (ProgCtx.shouldSpillStackPointer()) {
    IGC.MBB.addLiveIn(RealStackPointer);
    SnippyTgt.generateSpillToStack(IGC, RealStackPointer, AuxReg);
  }

  if (RealStackPointer != AuxReg)
    SnippyTgt.copyRegToReg(IGC, AuxReg, RealStackPointer);
}

void PrologueEpilogueInsertion::generateStackTermination(
    InstructionGenerationContext &IGC) {
  auto &ProgCtx = IGC.ProgCtx;
  auto &State = ProgCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  auto RealStackPointer = ProgCtx.getStackPointer();
  auto &MBB = IGC.MBB;

  // If honor-target-abi is specified and chosen stack pointer is preserved
  // we:
  // 1. choose auxillary register to generate reload of preserved stack
  // pointer relative to it
  // 3. copy stack pointer value to this auxillary register
  // 4. reload preserved stack pointer relatively to auxillary register
  auto AuxReg = RealStackPointer;
  if (ProgCtx.shouldSpillStackPointer()) {
    AuxReg = getRegisterForPreservedSPSpill(ProgCtx, MBB);
    SnippyTgt.copyRegToReg(IGC, RealStackPointer, AuxReg);
    SnippyTgt.generateReloadFromStack(IGC, RealStackPointer, AuxReg);
  }

  restoreStackPointer(IGC, AuxReg);
}

static void generateSpillToMem(InstructionGenerationContext &IGC,
                               ArrayRef<MCRegister> SpilledToMem) {
  auto &MBB = IGC.MBB;
  auto RP = IGC.pushRegPool();
  auto &ProgCtx = IGC.ProgCtx;
  if (!ProgCtx.hasProgramStateSaveSpace())
    snippy::fatal(
        "Cannot save global program state: no utility section in layout");
  auto &SaveLocs = ProgCtx.getProgramStateSaveSpace();
  llvm::for_each(SpilledToMem, [&](auto Reg) { RP->addReserved(Reg); });
  auto &State = ProgCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  llvm::for_each(SpilledToMem, [&](auto Reg) {
    MBB.addLiveIn(Reg);
    auto Addr = SaveLocs.getSaveLocation(Reg).Global;
    SnippyTgt.generateSpillToAddr(IGC, Reg, Addr);
  });
}

bool PrologueEpilogueInsertion::insertPrologue(
    MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
    ArrayRef<MCRegister> SpilledToMem) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &FG = getAnalysis<FunctionGenerator>();
  auto &ProgCtx = SGCtx.getProgramContext();
  auto &State = ProgCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  bool IsEntry = FG.isEntryFunction(MF);

  // Only Entry function out of all root functions has prologue.
  if (!IsEntry && FG.isRootFunction(MF))
    return false;

  auto &&[MBB, Ins] = findPlaceForPrologue(MF);

  InstructionGenerationContext InstrGenCtx{*MBB, Ins, SGCtx};
  auto RP = InstrGenCtx.pushRegPool();

  // Forbid spilled registers to be potentially used as scratch registers
  // for address forming.
  for (auto SpillReg : SpilledToStack)
    RP->addReserved(SpillReg);

  if (IsEntry && !SpilledToMem.empty())
    generateSpillToMem(InstrGenCtx, SpilledToMem);

  if (IsEntry)
    generateStackInitialization(InstrGenCtx);

  auto SP = SGCtx.getProgramContext().getStackPointer();
  // Spill requested registers. Also mark them as live-in.
  for (auto SpillReg : SpilledToStack) {
    MBB->addLiveIn(SpillReg);
    SnippyTgt.generateSpillToStack(InstrGenCtx, SpillReg, SP);
  }

  if (!IsEntry)
    return true;
  auto &SM = InstrGenCtx.getSnippyModule();
  SM.getOrAddResult<ObjectMetadata>().EntryPrologueInstrCnt =
      std::distance(MBB->begin(), Ins);
  // For entry also check that function still fits assigned section
  // after prologue insertion
  auto &&[FSize, SectionInfo] = getFunctionSizeInfo(MF);
  auto PrologueSize = State.getCodeBlockSize(MBB->begin(), Ins);

  // Do not report error here if function doesn't fit even without prologue.
  // That error would be displayed further in FunctionDistributePass.
  if (FSize <= SectionInfo.Size || FSize - PrologueSize > SectionInfo.Size)
    return true;

  std::string Message;
  llvm::raw_string_ostream OS{Message};
  OS << "Function '" << MF.getName() << "' won't fit into assigned section '"
     << SectionInfo.getIDString() << "' of size " << SectionInfo.Size
     << " after prologue insertion\n";
  OS << "Total function size: " << FSize << "; Prologue size: " << PrologueSize;
  snippy::fatal(StringRef(Message));
}

bool PrologueEpilogueInsertion::insertEpilogue(
    MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
    ArrayRef<MCRegister> SpilledToMem) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &FG = getAnalysis<FunctionGenerator>();
  auto &ProgCtx = SGCtx.getProgramContext();
  auto &State = ProgCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  bool IsExit = FG.isExitFunction(MF);

  // Only Exit function out of all root functions has epilogue.
  if (!IsExit && FG.isRootFunction(MF))
    return false;

  auto &&[MBB, Ins] = findPlaceForEpilogue(MF);
  InstructionGenerationContext InstrGenCtx{*MBB, Ins, SGCtx};
  auto RP = InstrGenCtx.pushRegPool();
  // Forbid spilled registers to be potentially used as scratch registers
  // for address forming.
  for (auto SpillReg : SpilledToStack)
    RP->addReserved(SpillReg);

  bool BBWasEmptyBeforeEpilogueInsertion = MBB->empty();
  auto Prev = BBWasEmptyBeforeEpilogueInsertion ? MBB->end() : std::prev(Ins);

  auto SP = SGCtx.getProgramContext().getStackPointer();
  // Reload spilled registers. Reverse order because of a stack.
  llvm::for_each(llvm::reverse(SpilledToStack), [&](auto Reg) {
    SnippyTgt.generateReloadFromStack(InstrGenCtx, Reg, SP);
  });

  if (IsExit)
    generateStackTermination(InstrGenCtx);

  if (IsExit && !SpilledToMem.empty()) {
    // Reload order is indifferent when loading from memory.
    auto &ProgCtx = SGCtx.getProgramContext();
    if (!ProgCtx.hasProgramStateSaveSpace())
      snippy::fatal(
          "Cannot save global program state: no utility section in layout");
    auto &SaveLocs = ProgCtx.getProgramStateSaveSpace();
    llvm::for_each(SpilledToMem, [&](auto Reg) {
      auto Addr = SaveLocs.getSaveLocation(Reg).Global;
      SnippyTgt.generateReloadFromAddr(InstrGenCtx, Reg, Addr);
    });
  }

  auto FirstInserted =
      BBWasEmptyBeforeEpilogueInsertion ? MBB->begin() : std::next(Prev);
  if (!IsExit)
    return true;
  auto &SM = InstrGenCtx.getSnippyModule();
  SM.getOrAddResult<ObjectMetadata>().EntryEpilogueInstrCnt =
      std::distance(FirstInserted, MBB->end());
  // For exit also check that function still fits assigned section
  // after epilogue insertion
  auto &&[FSize, SectionInfo] = getFunctionSizeInfo(MF);
  auto EpilogueSize = State.getCodeBlockSize(FirstInserted, MBB->end());

  // Do not report error here if function doesn't fit even without epilogue.
  // That error would be displayed further in FunctionDistributePass.
  if (FSize <= SectionInfo.Size || FSize - EpilogueSize > SectionInfo.Size)
    return true;

  std::string Message;
  llvm::raw_string_ostream OS{Message};
  OS << "Function '" << MF.getName() << "' won't fit into assigned section '"
     << SectionInfo.getIDString() << "' of size " << SectionInfo.Size
     << " after epilogue insertion\n";
  OS << "Total function size: " << FSize << "; Epilogue size: " << EpilogueSize;
  snippy::fatal(StringRef(Message));
}

bool PrologueEpilogueInsertion::runOnMachineFunction(MachineFunction &MF) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();

  if (!SGCtx.getProgramContext().stackEnabled())
    return false;

  auto SpilledToStack = getSpilledRegs(MF);
  auto SpilledToMem = SGCtx.getGenSettings().getRegsSpilledToMem();
  auto PrologueInserted = insertPrologue(MF, SpilledToStack, SpilledToMem);
  auto EpilogueInserted = insertEpilogue(MF, SpilledToStack, SpilledToMem);

  return PrologueInserted || EpilogueInserted;
}

} // namespace snippy
} // namespace llvm
