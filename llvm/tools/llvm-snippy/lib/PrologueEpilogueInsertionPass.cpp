//===-- PrologueEpilogueInsertionPass.cpp -----------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "CreatePasses.h"
#include "GeneratorContextPass.h"
#include "InitializePasses.h"

#include "snippy/Generator/LLVMState.h"
#include "snippy/Target/Target.h"

#include "llvm/CodeGen/MachineFunctionPass.h"

#define DEBUG_TYPE "snippy-prologue-epilogue-insertion"
#define PASS_DESC "Snippy Prologue Epilogue Insertion"

namespace llvm {
namespace snippy {
namespace {

struct PrologueEpilogueInsertion final : public MachineFunctionPass {
public:
  static char ID;

  PrologueEpilogueInsertion();

  StringRef getPassName() const override { return PASS_DESC " Pass"; }

  bool runOnMachineFunction(MachineFunction &MF) override;

  bool insertPrologue(MachineFunction &MF, std::vector<unsigned> &SpilledRegs);
  bool insertEpilogue(MachineFunction &MF, std::vector<unsigned> &SpilledRegs);

  auto getFunctionSizeInfo(const MachineFunction &MF) const {
    auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
    return std::make_pair(SGCtx.getFunctionSize(MF),
                          SGCtx.getOutputSectionFor(MF));
  }

  auto getAllMutatedRegs(MachineFunction &MF) {
    DenseSet<unsigned> MutatedRegs;
    for (auto &MBB : MF)
      for (auto &MI : MBB) {
        for (auto &Def : MI.defs()) {
          assert(Def.isReg() && "Expected register operand");
          MutatedRegs.insert(Def.getReg());
        }
        for (auto &Imp : MI.implicit_operands())
          if (Imp.isDef()) {
            assert(Imp.isReg() && "Expected register operand");
            MutatedRegs.insert(Imp.getReg());
          }
      }
    return MutatedRegs;
  }

  auto getSpilledRegs(MachineFunction &MF) {
    auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
    bool IsRoot = SGCtx.getCallGraphState().isRoot(&MF.getFunction());

    std::vector<unsigned> Ret;

    if (IsRoot)
      std::copy(SGCtx.getSpilledRegs().begin(), SGCtx.getSpilledRegs().end(),
                std::back_inserter(Ret));
    else {
      auto RegSet = getAllMutatedRegs(MF);
      std::copy(RegSet.begin(), RegSet.end(), std::back_inserter(Ret));
    }

    return Ret;
  }

  void generateStackInitialization(MachineBasicBlock &MBB,
                                   MachineBasicBlock::iterator Ins,
                                   RegPoolWrapper &RP);
  void generateStackTermination(MachineBasicBlock &MBB,
                                MachineBasicBlock::iterator Ins,
                                RegPoolWrapper &RP);

  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForPrologue(MachineFunction &MF);
  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForEpilogue(MachineFunction &MF);

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.setPreservesCFG();
    AU.addRequired<GeneratorContextWrapper>();
    MachineFunctionPass::getAnalysisUsage(AU);
  }
};

char PrologueEpilogueInsertion::ID = 0;

} // namespace
} // namespace snippy
} // namespace llvm

using llvm::callDefaultCtor;
using llvm::PassInfo;
using llvm::PassRegistry;
using llvm::snippy::PrologueEpilogueInsertion;

INITIALIZE_PASS(PrologueEpilogueInsertion, DEBUG_TYPE, PASS_DESC, false, false)

namespace llvm {

MachineFunctionPass *createPrologueEpilogueInsertionPass() {
  return new PrologueEpilogueInsertion();
}

namespace snippy {

PrologueEpilogueInsertion::PrologueEpilogueInsertion()
    : MachineFunctionPass(ID) {
  initializePrologueEpilogueInsertionPass(*PassRegistry::getPassRegistry());
}

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForPrologue(MachineFunction &MF) {
  return std::make_pair(&MF.front(), MF.front().begin());
}

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForEpilogue(MachineFunction &MF) {
  auto &MBB = MF.back();

  // FIXME: we need to insert epilogue right before last instruction
  // generated by snippy. For now we know that it is single instruction
  // in the end of last basic block and that it is not required to be
  // terminator.
  auto InsertPos = MBB.empty() ? MBB.end() : std::prev(MBB.end());
  return std::make_pair(&MBB, InsertPos);
}

static MCRegister getRegisterForPreservedSPSpill(GeneratorContext &SGCtx,
                                                 MachineBasicBlock &MBB) {
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  // If external stack is specified, we can use target-default stack pointer as
  // auxillary, because it is already initialized
  if (SGCtx.hasExternalStack())
    return SnippyTgt.getStackPointer();

  auto RP = SGCtx.getRegisterPool();
  const auto &RI = State.getRegInfo();
  const auto &RegClass = SnippyTgt.getRegClassSuitableForSP(RI);
  return RP.getAvailableRegister("scratch register for preserved reg spill", RI,
                                 RegClass, MBB);
}

static void setupStackPointer(MCRegister AuxReg, GeneratorContext &SGCtx,
                              MachineBasicBlock &MBB,
                              MachineBasicBlock::iterator Ins,
                              RegPoolWrapper &RP) {
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  auto TargetStackPointer = SnippyTgt.getStackPointer();

  if (SGCtx.hasExternalStack()) {
    if (AuxReg != TargetStackPointer) // If we use external stack and redefine
                                      // stack pointer register in snippet, we
                                      // need to initialize redefined stack
                                      // pointer with the value in external one
      SnippyTgt.copyRegToReg(MBB, Ins, TargetStackPointer, AuxReg, SGCtx);
    return;
  }

  // Stack ponter is considered live on entry.
  MBB.addLiveIn(AuxReg);

  // Initialize stack.
  // This requires two steps:
  // 1 - save current stack pointer state to top of stack.
  // 2 - set stack pointer to point to next stack slot.
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(AuxReg, SGCtx);
  auto Addr = SGCtx.getStackTop() - SPSpillSize;
  assert(Addr % SPSpillSize == 0u && "Stack section must be properly aligned");
  SnippyTgt.storeRegToAddr(MBB, Ins, Addr, AuxReg, RP, SGCtx,
                           /* store the whole register */ 0);
  auto SPInitValue = Addr;
  SnippyTgt.writeValueToReg(
      MBB, Ins,
      APInt(SnippyTgt.getAddrRegLen(State.getTargetMachine()), SPInitValue),
      AuxReg, RP, SGCtx);
}

static void restoreStackPointer(MCRegister AuxReg, GeneratorContext &SGCtx,
                                MachineBasicBlock &MBB,
                                MachineBasicBlock::iterator Ins,
                                RegPoolWrapper &RP) {
  const auto &SnippyTgt = SGCtx.getLLVMState().getSnippyTarget();
  auto TargetStackPointer = SnippyTgt.getStackPointer();

  if (SGCtx.hasExternalStack()) {
    if (AuxReg != TargetStackPointer) // Like during stack initialization,
                                      // both `external-stack` and
                                      // `redefine-sp` are specified, copying
                                      // stack pointer value to target-default
                                      // stack pointer is necessary on exit
      SnippyTgt.copyRegToReg(MBB, Ins, AuxReg, TargetStackPointer, SGCtx);
    return;
  }

  // Restore stack pointer state.
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(AuxReg, SGCtx);
  auto Addr = SGCtx.getStackTop() - SPSpillSize;
  SnippyTgt.loadRegFromAddr(MBB, Ins, Addr, AuxReg, RP, SGCtx);
}

void PrologueEpilogueInsertion::generateStackInitialization(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator Ins,
    RegPoolWrapper &RP) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  auto RealStackPointer = SGCtx.getStackPointer();
  auto TargetStackPointer = SnippyTgt.getStackPointer();

  auto AuxReg = RealStackPointer;
  auto ABIPreserved = SnippyTgt.getRegsPreservedByABI();
  bool IsRealSPPreserved =
      std::any_of(ABIPreserved.begin(), ABIPreserved.end(),
                  [RealStackPointer](auto PreservedReg) {
                    return PreservedReg == RealStackPointer;
                  });

  // If honor-target-abi is specified and register, chosen for stack pointer
  // redefinition, is preserved, we:
  // 1. choose auxillary register, relatively to which we spill this redefined
  // stack pointer
  // 2. initialize stack with auxillary register as stack pointer
  // 3. spill "preserved stack pointer" relatively to auxillary register
  // 4. copy contents of auxillary register to "preserved stack pointer"

  if (SGCtx.followTargetABI() && IsRealSPPreserved)
    AuxReg = getRegisterForPreservedSPSpill(SGCtx, MBB);

  setupStackPointer(AuxReg, SGCtx, MBB, Ins, RP);

  // Spilling of preserved register, chosen for stack pointer role
  if (SGCtx.followTargetABI() && IsRealSPPreserved) {
    MBB.addLiveIn(RealStackPointer);
    SnippyTgt.generateSpill(MBB, Ins, RealStackPointer, SGCtx, AuxReg);
  }

  if (RealStackPointer != AuxReg)
    SnippyTgt.copyRegToReg(MBB, Ins, AuxReg, RealStackPointer, SGCtx);
}

void PrologueEpilogueInsertion::generateStackTermination(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator Ins,
    RegPoolWrapper &RP) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  auto RealStackPointer = SGCtx.getStackPointer();
  auto TargetStackPointer = SnippyTgt.getStackPointer();
  auto AuxReg = RealStackPointer;

  auto ABIPreserved = SnippyTgt.getRegsPreservedByABI();
  bool IsRealSPPreserved =
      std::any_of(ABIPreserved.begin(), ABIPreserved.end(),
                  [RealStackPointer](auto PreservedReg) {
                    return PreservedReg == RealStackPointer;
                  });

  // If honor-target-abi is specified and chosen stack pointer is preserved
  // we:
  // 1. choose auxillary register to generate reload of preserved stack
  // pointer relative to it
  // 3. copy stack pointer value to this auxillary register
  // 4. reload preserved stack pointer relatively to auxillary register
  if (SGCtx.followTargetABI() && IsRealSPPreserved) {
    AuxReg = getRegisterForPreservedSPSpill(SGCtx, MBB);
    SnippyTgt.copyRegToReg(MBB, Ins, RealStackPointer, AuxReg, SGCtx);
    SnippyTgt.generateReload(MBB, Ins, RealStackPointer, SGCtx, AuxReg);
  }

  restoreStackPointer(AuxReg, SGCtx, MBB, Ins, RP);
}

bool PrologueEpilogueInsertion::insertPrologue(
    MachineFunction &MF, std::vector<unsigned> &SpilledRegs) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  bool IsEntry = SGCtx.isEntryFunction(MF);

  // Only Entry function out of all root functions has prologue.
  if (!IsEntry && SGCtx.getCallGraphState().isRoot(&MF.getFunction()))
    return false;

  auto &&[MBB, Ins] = findPlaceForPrologue(MF);

  // Forbid spilled registers to be potentially used as scratch registers
  // for address forming.
  auto RP = SGCtx.getRegisterPool();
  for (auto SpillReg : SpilledRegs)
    RP.addReserved(SpillReg);

  if (IsEntry)
    generateStackInitialization(*MBB, Ins, RP);

  auto SP = SGCtx.getStackPointer();
  // Spill requested registers. Also mark them as live-in.
  for (auto SpillReg : SpilledRegs) {
    MBB->addLiveIn(SpillReg);
    SnippyTgt.generateSpill(*MBB, Ins, SpillReg, SGCtx, SP);
  }
  if (!IsEntry)
    return true;
  SGCtx.setEntryPrologueInstructionCount(std::distance(MBB->begin(), Ins));

  // For entry also check that function still fits assigned section
  // after prologue insertion
  auto &&[FSize, SectionInfo] = getFunctionSizeInfo(MF);
  auto PrologueSize = SGCtx.getCodeBlockSize(MBB->begin(), Ins);

  // Do not report error here if function doesn't fit even without prologue.
  // That error would be displayed further in FunctionDistributePass.
  if (FSize <= SectionInfo.Size || FSize - PrologueSize > SectionInfo.Size)
    return true;

  std::string Message;
  llvm::raw_string_ostream OS{Message};
  OS << "Function '" << MF.getName() << "' won't fit into assigned section '"
     << SectionInfo.getIDString() << "' of size " << SectionInfo.Size
     << " after prologue insertion\n";
  OS << "Total function size: " << FSize << "; Prologue size: " << PrologueSize;
  report_fatal_error(StringRef(Message), false);
}

bool PrologueEpilogueInsertion::insertEpilogue(
    MachineFunction &MF, std::vector<unsigned> &SpilledRegs) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  bool IsExit = SGCtx.isExitFunction(MF);

  // Only Exit function out of all root functions has epilogue.
  if (!IsExit && SGCtx.getCallGraphState().isRoot(&MF.getFunction()))
    return false;

  // Forbid spilled registers to be potentially used as scratch registers
  // for address forming.
  auto RP = SGCtx.getRegisterPool();
  for (auto SpillReg : SpilledRegs)
    RP.addReserved(SpillReg);

  auto &&[MBB, Ins] = findPlaceForEpilogue(MF);
  bool BBWasEmptyBeforeEpilogueInsertion = MBB->empty();
  auto Prev = BBWasEmptyBeforeEpilogueInsertion ? MBB->end() : std::prev(Ins);

  auto SP = SGCtx.getStackPointer();
  // Reload spilled registers.
  std::for_each(SpilledRegs.rbegin(), SpilledRegs.rend(),
                [&, MBB = MBB, Ins = Ins](auto Reg) {
                  SnippyTgt.generateReload(*MBB, Ins, Reg, SGCtx, SP);
                });

  if (IsExit)
    generateStackTermination(*MBB, Ins, RP);

  auto FirstInserted =
      BBWasEmptyBeforeEpilogueInsertion ? MBB->begin() : std::next(Prev);
  if (!IsExit)
    return true;
  SGCtx.setEntryEpilogueInstuctionCount(
      std::distance(FirstInserted, MBB->end()));

  // For exit also check that function still fits assigned section
  // after epilogue insertion
  auto &&[FSize, SectionInfo] = getFunctionSizeInfo(MF);
  auto EpilogueSize = SGCtx.getCodeBlockSize(FirstInserted, MBB->end());

  // Do not report error here if function doesn't fit even without epilogue.
  // That error would be displayed further in FunctionDistributePass.
  if (FSize <= SectionInfo.Size || FSize - EpilogueSize > SectionInfo.Size)
    return true;

  std::string Message;
  llvm::raw_string_ostream OS{Message};
  OS << "Function '" << MF.getName() << "' won't fit into assigned section '"
     << SectionInfo.getIDString() << "' of size " << SectionInfo.Size
     << " after epilogue insertion\n";
  OS << "Total function size: " << FSize << "; Epilogue size: " << EpilogueSize;
  report_fatal_error(StringRef(Message), false);
}

bool PrologueEpilogueInsertion::runOnMachineFunction(MachineFunction &MF) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();

  if (!SGCtx.stackEnabled())
    return false;

  auto SpilledRegs = getSpilledRegs(MF);
  auto PrologueInserted = insertPrologue(MF, SpilledRegs);
  auto EpilogueInserted = insertEpilogue(MF, SpilledRegs);

  return PrologueInserted || EpilogueInserted;
}

} // namespace snippy
} // namespace llvm
