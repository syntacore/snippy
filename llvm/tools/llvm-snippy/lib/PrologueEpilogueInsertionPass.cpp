//===-- PrologueEpilogueInsertionPass.cpp -----------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "InitializePasses.h"

#include "snippy/CreatePasses.h"
#include "snippy/Generator/GeneratorContextPass.h"

#include "llvm/ADT/STLExtras.h"
#include "llvm/CodeGen/MachineFunctionPass.h"

#define DEBUG_TYPE "snippy-prologue-epilogue-insertion"
#define PASS_DESC "Snippy Prologue Epilogue Insertion"

namespace llvm {
namespace snippy {
namespace {

struct PrologueEpilogueInsertion final : public MachineFunctionPass {
public:
  static char ID;

  PrologueEpilogueInsertion() : MachineFunctionPass(ID) {}

  StringRef getPassName() const override { return PASS_DESC " Pass"; }

  bool runOnMachineFunction(MachineFunction &MF) override;

  bool insertPrologue(MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
                      ArrayRef<MCRegister> SpilledToMem);
  bool insertEpilogue(MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
                      ArrayRef<MCRegister> SpilledToMem);

  auto getFunctionSizeInfo(const MachineFunction &MF) const {
    auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
    return std::make_pair(SGCtx.getFunctionSize(MF),
                          SGCtx.getProgramContext().getOutputSectionFor(MF));
  }

  auto getAllMutatedRegs(MachineFunction &MF) {
    DenseSet<unsigned> MutatedRegs;
    for (auto &MBB : MF)
      for (auto &MI : MBB) {
        for (auto &Def : MI.defs()) {
          assert(Def.isReg() && "Expected register operand");
          MutatedRegs.insert(Def.getReg());
        }
        for (auto &Imp : MI.implicit_operands())
          if (Imp.isDef()) {
            assert(Imp.isReg() && "Expected register operand");
            MutatedRegs.insert(Imp.getReg());
          }
      }
    return MutatedRegs;
  }

  auto getSpilledRegs(MachineFunction &MF) {
    auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
    bool IsRoot = SGCtx.isRootFunction(MF);

    std::vector<MCRegister> Ret;

    if (IsRoot)
      llvm::copy(SGCtx.getRegsSpilledToStack(), std::back_inserter(Ret));
    else {
      auto RegSet = getAllMutatedRegs(MF);
      llvm::copy(RegSet, std::back_inserter(Ret));
    }

    return Ret;
  }

  void generateStackInitialization(MachineBasicBlock &MBB,
                                   MachineBasicBlock::iterator Ins,
                                   RegPoolWrapper &RP);
  void generateStackTermination(MachineBasicBlock &MBB,
                                MachineBasicBlock::iterator Ins,
                                RegPoolWrapper &RP);

  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForPrologue(MachineFunction &MF);
  std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
  findPlaceForEpilogue(MachineFunction &MF);

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.setPreservesCFG();
    AU.addRequired<GeneratorContextWrapper>();
    MachineFunctionPass::getAnalysisUsage(AU);
  }
};

char PrologueEpilogueInsertion::ID = 0;

} // namespace
} // namespace snippy
} // namespace llvm

using llvm::callDefaultCtor;
using llvm::PassInfo;
using llvm::PassRegistry;
using llvm::snippy::PrologueEpilogueInsertion;

INITIALIZE_PASS(PrologueEpilogueInsertion, DEBUG_TYPE, PASS_DESC, false, false)

namespace llvm {

MachineFunctionPass *createPrologueEpilogueInsertionPass() {
  return new PrologueEpilogueInsertion();
}

namespace snippy {

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForPrologue(MachineFunction &MF) {
  return std::make_pair(&MF.front(), MF.front().begin());
}

std::pair<MachineBasicBlock *, MachineBasicBlock::iterator>
PrologueEpilogueInsertion::findPlaceForEpilogue(MachineFunction &MF) {
  auto &MBB = MF.back();

  // FIXME: we need to insert epilogue right before last instruction
  // generated by snippy. For now we know that it is single instruction
  // in the end of last basic block and that it is not required to be
  // terminator.
  auto InsertPos = MBB.empty() ? MBB.end() : std::prev(MBB.end());
  return std::make_pair(&MBB, InsertPos);
}

static MCRegister getRegisterForPreservedSPSpill(GeneratorContext &SGCtx,
                                                 MachineBasicBlock &MBB) {
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  // If external stack is specified, we can use target-default stack pointer as
  // auxillary, because it is already initialized
  if (SGCtx.getProgramContext().hasExternalStack())
    return SnippyTgt.getStackPointer();

  auto RP = SGCtx.getRegisterPool();
  const auto &RI = State.getRegInfo();
  const auto &RegClass = SnippyTgt.getRegClassSuitableForSP(RI);
  return RP.getAvailableRegister("scratch register for preserved reg spill", RI,
                                 RegClass, MBB);
}

static void setupStackPointer(MCRegister AuxReg, GeneratorContext &SGCtx,
                              MachineBasicBlock &MBB,
                              MachineBasicBlock::iterator Ins,
                              RegPoolWrapper &RP) {
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  auto TargetStackPointer = SnippyTgt.getStackPointer();

  if (SGCtx.getProgramContext().hasExternalStack()) {
    if (AuxReg != TargetStackPointer) // If we use external stack and redefine
                                      // stack pointer register in snippet, we
                                      // need to initialize redefined stack
                                      // pointer with the value in external one
      SnippyTgt.copyRegToReg(MBB, Ins, TargetStackPointer, AuxReg, SGCtx);
    return;
  }

  // Stack ponter is considered live on entry.
  MBB.addLiveIn(AuxReg);

  // Initialize stack.
  // This requires two steps:
  // 1 - save current stack pointer state to top of stack.
  // 2 - set stack pointer to point to next stack slot.
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(AuxReg, SGCtx);
  auto Addr = SGCtx.getProgramContext().getStackTop() - SPSpillSize;
  assert(Addr % SPSpillSize == 0u && "Stack section must be properly aligned");
  if (!SGCtx.isRegSpilledToMem(AuxReg))
    SnippyTgt.storeRegToAddr(MBB, Ins, Addr, AuxReg, RP, SGCtx,
                             /* store the whole register */ 0);
  auto SPInitValue = Addr;
  SnippyTgt.writeValueToReg(
      MBB, Ins,
      APInt(SnippyTgt.getAddrRegLen(State.getTargetMachine()), SPInitValue),
      AuxReg, RP, SGCtx);
}

static void restoreStackPointer(MCRegister AuxReg, GeneratorContext &SGCtx,
                                MachineBasicBlock &MBB,
                                MachineBasicBlock::iterator Ins,
                                RegPoolWrapper &RP) {
  const auto &SnippyTgt = SGCtx.getLLVMState().getSnippyTarget();
  auto TargetStackPointer = SnippyTgt.getStackPointer();

  if (SGCtx.getProgramContext().hasExternalStack()) {
    if (AuxReg != TargetStackPointer) // Like during stack initialization,
                                      // both `external-stack` and
                                      // `redefine-sp` are specified, copying
                                      // stack pointer value to target-default
                                      // stack pointer is necessary on exit
      SnippyTgt.copyRegToReg(MBB, Ins, AuxReg, TargetStackPointer, SGCtx);
    return;
  }

  // Restore stack pointer state.
  auto SPSpillSize = SnippyTgt.getSpillSizeInBytes(AuxReg, SGCtx);
  auto Addr = SGCtx.getProgramContext().getStackTop() - SPSpillSize;
  SnippyTgt.loadRegFromAddr(MBB, Ins, Addr, AuxReg, RP, SGCtx);
}

void PrologueEpilogueInsertion::generateStackInitialization(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator Ins,
    RegPoolWrapper &RP) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  auto RealStackPointer = SGCtx.getProgramContext().getStackPointer();

  // If honor-target-abi is specified and register, chosen for stack pointer
  // redefinition, is preserved, we:
  // 1. choose auxillary register, relatively to which we spill this redefined
  // stack pointer
  // 2. initialize stack with auxillary register as stack pointer
  // 3. spill "preserved stack pointer" relatively to auxillary register
  // 4. copy contents of auxillary register to "preserved stack pointer"
  auto AuxReg = RealStackPointer;
  if (SGCtx.getProgramContext().shouldSpillStackPointer())
    AuxReg = getRegisterForPreservedSPSpill(SGCtx, MBB);

  setupStackPointer(AuxReg, SGCtx, MBB, Ins, RP);

  // Spilling of preserved register, chosen for stack pointer role
  if (SGCtx.getProgramContext().shouldSpillStackPointer()) {
    MBB.addLiveIn(RealStackPointer);
    SnippyTgt.generateSpillToStack(MBB, Ins, RealStackPointer, SGCtx, AuxReg);
  }

  if (RealStackPointer != AuxReg)
    SnippyTgt.copyRegToReg(MBB, Ins, AuxReg, RealStackPointer, SGCtx);
}

void PrologueEpilogueInsertion::generateStackTermination(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator Ins,
    RegPoolWrapper &RP) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  auto RealStackPointer = SGCtx.getProgramContext().getStackPointer();

  // If honor-target-abi is specified and chosen stack pointer is preserved
  // we:
  // 1. choose auxillary register to generate reload of preserved stack
  // pointer relative to it
  // 3. copy stack pointer value to this auxillary register
  // 4. reload preserved stack pointer relatively to auxillary register
  auto AuxReg = RealStackPointer;
  if (SGCtx.getProgramContext().shouldSpillStackPointer()) {
    AuxReg = getRegisterForPreservedSPSpill(SGCtx, MBB);
    SnippyTgt.copyRegToReg(MBB, Ins, RealStackPointer, AuxReg, SGCtx);
    SnippyTgt.generateReloadFromStack(MBB, Ins, RealStackPointer, SGCtx,
                                      AuxReg);
  }

  restoreStackPointer(AuxReg, SGCtx, MBB, Ins, RP);
}

static void generateSpillToMem(ArrayRef<MCRegister> SpilledToMem,
                               GeneratorContext &SGCtx, MachineBasicBlock &MBB,
                               MachineBasicBlock::iterator Ins) {
  auto RP = SGCtx.getRegisterPool();
  llvm::for_each(SpilledToMem, [&](auto Reg) { RP.addReserved(Reg); });
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();
  llvm::for_each(SpilledToMem, [&](auto Reg) {
    if (!SGCtx.hasSpillAddrsForReg(Reg))
      SGCtx.reserveSpillAddrsForReg(Reg);
    MBB.addLiveIn(Reg);
    auto Addr = SGCtx.getSpilledRegAddrGlobal(Reg);
    SnippyTgt.generateSpillToAddr(MBB, Ins, Reg, Addr, SGCtx);
  });
}

bool PrologueEpilogueInsertion::insertPrologue(
    MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
    ArrayRef<MCRegister> SpilledToMem) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  bool IsEntry = SGCtx.isEntryFunction(MF);

  // Only Entry function out of all root functions has prologue.
  if (!IsEntry && SGCtx.isRootFunction(MF))
    return false;

  auto &&[MBB, Ins] = findPlaceForPrologue(MF);

  // Forbid spilled registers to be potentially used as scratch registers
  // for address forming.
  auto RP = SGCtx.getRegisterPool();
  for (auto SpillReg : SpilledToStack)
    RP.addReserved(SpillReg);

  if (IsEntry)
    generateSpillToMem(SpilledToMem, SGCtx, *MBB, Ins);

  if (IsEntry)
    generateStackInitialization(*MBB, Ins, RP);

  auto SP = SGCtx.getProgramContext().getStackPointer();
  // Spill requested registers. Also mark them as live-in.
  for (auto SpillReg : SpilledToStack) {
    MBB->addLiveIn(SpillReg);
    SnippyTgt.generateSpillToStack(*MBB, Ins, SpillReg, SGCtx, SP);
  }

  if (!IsEntry)
    return true;
  SGCtx.setEntryPrologueInstructionCount(std::distance(MBB->begin(), Ins));
  // For entry also check that function still fits assigned section
  // after prologue insertion
  auto &&[FSize, SectionInfo] = getFunctionSizeInfo(MF);
  auto PrologueSize = SGCtx.getCodeBlockSize(MBB->begin(), Ins);

  // Do not report error here if function doesn't fit even without prologue.
  // That error would be displayed further in FunctionDistributePass.
  if (FSize <= SectionInfo.Size || FSize - PrologueSize > SectionInfo.Size)
    return true;

  std::string Message;
  llvm::raw_string_ostream OS{Message};
  OS << "Function '" << MF.getName() << "' won't fit into assigned section '"
     << SectionInfo.getIDString() << "' of size " << SectionInfo.Size
     << " after prologue insertion\n";
  OS << "Total function size: " << FSize << "; Prologue size: " << PrologueSize;
  report_fatal_error(StringRef(Message), false);
}

bool PrologueEpilogueInsertion::insertEpilogue(
    MachineFunction &MF, ArrayRef<MCRegister> SpilledToStack,
    ArrayRef<MCRegister> SpilledToMem) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();
  auto &State = SGCtx.getLLVMState();
  const auto &SnippyTgt = State.getSnippyTarget();

  bool IsExit = SGCtx.isExitFunction(MF);

  // Only Exit function out of all root functions has epilogue.
  if (!IsExit && SGCtx.isRootFunction(MF))
    return false;

  // Forbid spilled registers to be potentially used as scratch registers
  // for address forming.
  auto RP = SGCtx.getRegisterPool();
  for (auto SpillReg : SpilledToStack)
    RP.addReserved(SpillReg);

  auto &&[MBB, Ins] = findPlaceForEpilogue(MF);
  bool BBWasEmptyBeforeEpilogueInsertion = MBB->empty();
  auto Prev = BBWasEmptyBeforeEpilogueInsertion ? MBB->end() : std::prev(Ins);

  auto SP = SGCtx.getProgramContext().getStackPointer();
  // Reload spilled registers. Reverse order because of a stack.
  llvm::for_each(llvm::reverse(SpilledToStack),
                 [&, MBB = MBB, Ins = Ins](auto Reg) {
                   SnippyTgt.generateReloadFromStack(*MBB, Ins, Reg, SGCtx, SP);
                 });

  if (IsExit)
    generateStackTermination(*MBB, Ins, RP);

  if (IsExit) {
    // Reload order is indifferent when loading from memory.
    llvm::for_each(SpilledToMem, [&, MBB = MBB, Ins = Ins](auto Reg) {
      auto Addr = SGCtx.getSpilledRegAddrGlobal(Reg);
      SnippyTgt.generateReloadFromAddr(*MBB, Ins, Reg, Addr, SGCtx);
    });
  }

  auto FirstInserted =
      BBWasEmptyBeforeEpilogueInsertion ? MBB->begin() : std::next(Prev);
  if (!IsExit)
    return true;
  SGCtx.setEntryEpilogueInstuctionCount(
      std::distance(FirstInserted, MBB->end()));
  // For exit also check that function still fits assigned section
  // after epilogue insertion
  auto &&[FSize, SectionInfo] = getFunctionSizeInfo(MF);
  auto EpilogueSize = SGCtx.getCodeBlockSize(FirstInserted, MBB->end());

  // Do not report error here if function doesn't fit even without epilogue.
  // That error would be displayed further in FunctionDistributePass.
  if (FSize <= SectionInfo.Size || FSize - EpilogueSize > SectionInfo.Size)
    return true;

  std::string Message;
  llvm::raw_string_ostream OS{Message};
  OS << "Function '" << MF.getName() << "' won't fit into assigned section '"
     << SectionInfo.getIDString() << "' of size " << SectionInfo.Size
     << " after epilogue insertion\n";
  OS << "Total function size: " << FSize << "; Epilogue size: " << EpilogueSize;
  report_fatal_error(StringRef(Message), false);
}

bool PrologueEpilogueInsertion::runOnMachineFunction(MachineFunction &MF) {
  auto &SGCtx = getAnalysis<GeneratorContextWrapper>().getContext();

  if (!SGCtx.getProgramContext().stackEnabled())
    return false;

  auto SpilledToStack = getSpilledRegs(MF);
  auto SpilledToMem = SGCtx.getRegsSpilledToMem();
  auto PrologueInserted = insertPrologue(MF, SpilledToStack, SpilledToMem);
  auto EpilogueInserted = insertEpilogue(MF, SpilledToStack, SpilledToMem);

  return PrologueInserted || EpilogueInserted;
}

} // namespace snippy
} // namespace llvm
